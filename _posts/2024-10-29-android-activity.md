---
title: Android Activity
---

<br>

## 0) Android Activity
<br>


흔히 우리가 전통적인 '프로그램'을 사용할 때는, 하나의 진입점이 있었습니다.<br>

프로그램을 `실행`하면 `코드`가 `메모리`에 올라가 비로소 프로그램 하나가 동작하게 되죠.<br>

이 프로그램 실행을 담당하는 단 하나의 `진입점`을 우리는 `메인 함수`라고 불렀습니다.<br>


그런데, 안드로이드는 이러한 패러다임에서 벗어나 새로운 기준을 제시했어요.<br><br><br>


모바일 환경에서는 진입점이 하나가 아닙니다.<br>
예를 들어, 홈 화면에서 카카오톡을 실행하면 카카오톡 친구 목록이 기본으로 떠요.<br>
인터넷을 하다가 내가 사용하던 채팅방으로 다시 돌아올 수도 있고, 카카오톡으로 공유를 선택하면 공유화면이 뜨기도 하죠.<br><br>

모바일 환경에서 돌아가는 애플리케이션은, `여러 개의 진입점`이라는 새로운 패러다임을 폭발적으로 진화시켰답니다.<br><br>

그리고 구글은 마침내 이렇게 정의했어요.<br>
여러 진입점을 통해 사용자가 원하는 활동을 그 때 마다 `독립적`으로 보여주는 이 화면들의 모음을, `액티비티`라고 부르자구요.
<br><br><br><br><br><br>





## 1) Manifest, Intent
<br>

액티비티를 이해하려면 확실히 짚고 넘어가야 할 내용이 있어요.<br>
그 중 첫 번째가 바로 `매니페스트(Manifest)`에요.<br><br>


<center><img src="https://i.ibb.co/1q7zhk4/2024-10-28-9-37-00.png" alt=""></center>
<br><br>

매니페스트는 영어로 `명백한`이라는 의미를 담고 있습니다.<br>
뭘 명백히 한다는 걸까요? 바로 `컴포넌트들의 관계`를 명확히 한다는 의미입니다.<br><br>

꼬리에 꼬리를 무는 느낌이 들지만, 그럼 왜 명백히 해야할까요? 이는 우리가 `다른 언어로 빌드`할 때를 생각해보면 알 수 있습니다.<br><br>


좀 더 로우에 가까운 언어를 생각해봐요. 이를테면 C언어가 될 수 있겠죠.<br>

C언어로 만들어진 코드들을 실행하기 위해서는 다음과 같은 과정이 이루어집니다.

먼저 각 코드 파일을 기계어로 번역해서 컴퓨터가 알아먹을 수 있게 합니다. 이를 `컴파일`이라고 해요.<br>

두 번째로는 이렇게 컴파일된 오브젝트 파일들을 링커를 사용하여 서로 묶습니다. 이 때 외부 라이브러리들도 함께 포함돼요. 이를 `링크`라고 부릅니다.<br>

이 과정을 거치고나면 exe같은 `하나의 실행파일`이 나오게되고, 우리는 이를 `빌드`라고 부릅니다.<br><br><br>


안드로이드에서의 `빌드`는 결과물이 뭔가요? 하나의 애플리케이션이겠죠.<br>
말은 번지르르 하지만 결국 안드로이드도 로우언어들처럼 번역되고 합쳐지는 과정을 거칩니다.<br><br>

보통 안드로이드 스튜디오는 소스 편집을 지원해주고, 마지막으로 빌드는 Gradle같은 도구의 도움을 받죠.<br><br>

이 때 액티비티같은 `컴포넌트들이 어떤 구조로 이루어져 있는지 확인해 빌드할 수 있게 도와주는 파일`이 바로 매니페스트랍니다.<br>

```kotlin
<manifest ... >
  <application ... >
      <activity android:name=".ExampleActivity" />
      ...
  </application ... >
  ...
</manifest >
```
<br><br><br><br>

두 번째는 `Intent`입니다.<br>

<center><img src="https://i.ibb.co/rxZzMgB/2024-10-28-10-01-30.png" alt=""></center>
<br><br>

Intent는 그 의미 그대로 `어떠한 동작의 의도`를 가지고 있습니다.<br>
이는 `암시적`, `명시적` 의미를 모두 포함해요.<br><br>

가령, 어떤 페이지에서 `Gmail로 이메일 보내기`버튼을 눌렀다고 해봐요. 이는 `어디에서 무엇을 해줘`가 확실하게 명시되어있습니다. `명시적 intent`라고 할 수 있어요.<br><br>

반면, 버튼이 그저 `이메일 보내기`기능만 수행한다고 해보죠. 이 경우에는 의도가 명확하지 않기 때문에 어느 애플리케이션에서 intent를 실행할지 고르겠죠.<br>
이는 결국 `암시적 intent`라고 할 수 있어요.

<br><br>

아까 액티비티는 `독립적`으로 동작한다고 했죠?<br>
이는 액티비티 사이를 전환할 때 의도적으로 `intent`를 담아보낼 수 있음을 의미합니다.<br>
아래는 특정 액티비티를 시작하기 전, 텍스트와 이를 보낸다는 intent를 함께 보내는 예시에요.


```kotlin
val sendIntent = Intent().apply {
    action = Intent.ACTION_SEND
    type = "text/plain"
    putExtra(Intent.EXTRA_TEXT, textMessage)
}
startActivity(sendIntent)
```

<br><br><br><br><br><br>





## 2) Android Lifecycle
<br>

애플리케이션에는 `많은 진입점`이 있다고 말했어요.<br>
하지만 만약 특정한 목적을 가지고 진입했음에도 불구하고,<br>계속해서 같은 화면(예를 들면 첫 메인화면)만 보인다면, 굳이 진입점이 많을 필요도 없겠죠?<br><br>

또, 모든 애플리케이션을 항상 로딩없이 빠르게 볼 수 있게 실행하고 있으면 좋겠지만, 사용할 수 있는 시스템 자원에 한계도 명확하구요.<br><br>

그래서 액티비티는 `수명`을 가집니다. 안드로이드는 액티비티 클래스에서 이 수명을 관리할 수 있는 일련의 콜백함수를 제공해요. <br>
그리고 이를 활용해 액티비티의 수명이 관리되는 과정을 `안드로이드 생명주기`이라고 부릅니다.<br><br><br>


<center><img src="https://i.ibb.co/2js63H7/activity-lifecycle.png" alt=""></center>

<br><br>
- onCreate() <br>
액티비티의 `뼈대`가 만들어지는 과정이에요.<br>
이 콜백함수는 반드시 구현되어야합니다. 기본적인 UI를 설정하고, 데이터를 리스트에 바인딩 하는 등의 과정을 거쳐야 한답니다.


<br><br>
- onStart() <br>
onCreate()에서 설정한 UI가 사용자의 눈에 보이게되고, 상호작용하기 직전 상태에 놓이게 돼요.


<br><br>
- onResume() <br>
UI가 제일 최상단 포그라운드에 놓이게 되고, 사용자와의 모든 상호작용을 감지하게 돼요.
애플리케이션에 한 번 접근하면 결국 onResume()이 항상 실행되고 있으므로, 핵심적인 코드 내용은 여기에 정의된답니다.


<br><br>
- onPause() <br>
사용자가 뒤로가기 버튼을 눌러 *"애플리케이션을 종료할까요?"* 라는 다이얼로그를 띄웠다고 생각해봐요. <br>
다이얼로그 뒤로 보이는 액티비티는 아직 활발하게 움직이는 것 처럼 보이지만, "확인"을 누르는 순간 파괴될 위기에 처해있죠.<br>
이처럼 액티비티를 완전히 종료하기 전에 놓여있는 상태를 onPause()라고 한답니다.<br><br>
참고로, onPause()상태에서는 데이터베이스 트랜잭션을 실행하는 등의 `데이터와 관련된 행동`을 해서는 안돼요.<br>
곧 파괴될 액티비티일지도 모르는데 중요한 동작을 맡겨서는 안되니까요.<br><br><br><br>



- onStop()<br>
  확실하게 액티비티가 포그라운드에서 사라지게되면 호출돼요.<br>
  하지만 아직 메모리에서 유휴상태로 존재는 하고 있는 상태에요.<br>
  이제 이는 둘 중 하나의 메소드로 향할 수 있답니다.<br><br>
 `onRestart()`로 향하게 되면, onStart()를 거쳐 다시 액티비티가 포그라운드에 위치하게돼요.<br>
 `onDestroy()`로 향하게 되면, 액티비티가 메모리에서 해제됩니다. 이 때 액티비티에서 할당했던 리소스가 모두 해제되었는지도 체크하세요.
