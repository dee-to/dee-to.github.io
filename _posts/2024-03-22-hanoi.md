---
title: 하노이의 탑과 재귀구조
categories:
- C++
- 자료구조
tags:
- C++
- 자료구조
- 알고리즘
- 하노이의탑
---

<br>


하노이의 탑은 재귀호출구조를 설명하는 오래된 문제입니다. <br>
하지만 문제가 오래된거지 제 경력이 오래된건 아니기 때문에... 머리를 싸매고 문제를 풀어나가던 과정을 잠깐 적어볼까 합니다.

<br><br><br>

## 1) 재귀함수
<br>

재귀함수(recursion).<br>
정의 단계에서 자신을 재참조하는 함수를 뜻해요. 그러니까 그냥, `함수 내에서 자기자신을 또 불러오는 함수`를 의미합니다.
<br><br>

우리는 컴퓨터가 아니니까, 머릿 속으로 단순히 함수를 호출하고 또 호출하고 또 호출해서 스택에 쌓고 쌓고 쌓고 아하! 스택 순서가 이렇게 되는구나! 하는 마법을 부릴 수 있는 사람은 없어요.....아니 뭐 있긴하겠지만 적어도 전 아니었네요..
<br><br><br>

*재귀함수는 왜 쓸까요?*<br>
물론 보기에도 깔끔하고, 변수 사용을 극단적으로 줄여서 변경 가능성을 줄인다던지 하는 이유들은 찾아보면 많지만, 적어도 제가 확실하게 느낀건 `문제를 아주 작게 쪼개는데에 최적화 되어있다` 라고 생각해요.
<br><br><br><br><br><br><br><br>



## 2) 피보나치 수열
<br>

하노이의 탑과 양대산맥을 이루고 있는 재귀함수의 적. 피보나치 수열 구현문제는 아마 다들 익숙히 들어보셨을거에요.<br>
`모든 재귀문제는 반복문으로 풀 수 있습니다.` 반복문으로 푸는게 보기 어려워서 그렇지..
<br><br>

피보나치 수열로 비교해볼까요?
```cpp
// 재귀 형태
int fibbonacci_recursion(int n)
{
    if((n == 0) || (n == 1))
        return n;
    else   
        return fibbonacci_recursion(n - 1) + fibbonacci_recursion(n - 2);
}

// 반복문 형태
int fibonacci(int n) 
{
    if (n <= 1)
        return n;

    int first = 0, second = 1, next = 0;

    for (int i = 2; i <= n; i++) 
    {
        next = first + second;
        first = second;
        second = next;
    }

    return next;
}
```

음... 물론 재귀를 이해하고 있어야한다는 가정이 있겠지만,<br>
피보나치 수열의 일반식이 `f(n) = f(n - 1) + f(n - 2)`라는 것을 알고있기 때문에 재귀형태가 좀 더 깔끔하고 직관적으로 다가오죠.
<br><br>

일반식을 이끌어 낼 때에는 가장 알기 쉬운 것 부터 대입해서 귀납적으로 끌어내죠? 0 1 1 2 3 5 8 13 21 ...

재귀함수로 문제를 풀겠다는건, `문제를 알아볼 수 있는 단계까지 쪼개서 풀겠다`라는 말과 동일하니까, 이 생각을 가지고 다시 하노이의 탑에 다가가보도록 해요.
<br><br><br><br><br><br><br><br>


## 2) 하노이의 탑
<br>

가장 알기 쉬운 것 부터 알아보도록 해요.<br>

1) 원판이 하나인 경우<br>
    원판을 2번까지 옮긴다. 너무 당연한 이야기죠?<br>
		

![img1](https://i.ibb.co/nrp9SB8/1.gif){: height="10%"}
		

<br><br>

2) 원판이 두 개인 경우<br>
   맨 위의 원판을 1번으로 옮긴다.<br>
   다음 원판을 2번으로 옮긴다.<br>
   가운데에 있던 원판을 2번으로 옮긴다.<br>

![img2](https://i.ibb.co/p20VK1f/2.gif){: height="10%"}
   

<br><br>

피보나치 수열을 생각해보면, 함수를 재귀적으로 타고타고 가다가 결국 f(0)일 때와 f(1)일 때의 합으로 이루어졌었죠?<br><br>

결국 재귀함수는 `문제를 아주 작게 뜯고 또 뜯다보면 가장 기본적인 문제의 모임으로 이루어져있다`는 것을 깨닫는 과정인거에요.<br><br>

다시 원판이 두 개일 때를 보죠.<br>
맨 위의 원판을 제거하면 어떻게 되나요?<br>
결국 *원판이 하나일 때*의 경우가 원판이 두 개일때에 포함되는 구조입니다.<br>
원판이 세 개 일 때는 어떨까요?<br><br><br>



3) 원판이 세 개인 경우<br>
   맨 위의 원판을 2번으로 옮긴다.<br>
   그 다음 원판을 1번으로 옮긴다.<br>
   2번의 원판을 1번으로 옮긴다.<br>
   0번에 남아있는 제일 큰 원판을 2번으로 옮긴다.<br>
   1번의 원판을 0번으로 옮긴다.<br>
   1번의 원판을 2번으로 옮긴다.<br>
   0번의 원판을 2번으로 옮긴다.<br>
	 
![img3](https://i.ibb.co/8KWgTCN/3.gif){: height="10%"}


<br>

이제는 *`원판이 하나인 경우는 f(1), 두 개인 경우는 f(2), n개인 경우는 f(n)`* 이라고 해볼게요.<br><br>

원판이 하나인 경우와 원판이 둘인 경우가 어디에 포함되어있나요?<br><br>

```
원판이 세 개인 경우                 - f(3)
맨 위의 원판을 2번으로 옮긴다.      
그 다음 원판을 1번으로 옮긴다.      - f(2)
2번의 원판을 1번으로 옮긴다.
0번의 원판을 2번으로 옮긴다.        - f(1)
1번의 원판을 0번으로 옮긴다.
1번의 원판을 2번으로 옮긴다.        - f(2)
0번의 원판을 2번으로 옮긴다.
```

<br><br>

마찬가지로 네 개인 경우는요?

```
원판이 네 개인 경우                 - f(4)
원판을 0에서 1로 옮긴다.
원판을 0에서 2로 옮긴다.            - f(3)
원판을 1에서 2로 옮긴다.
원판을 0에서 1로 옮긴다.            - f(2)
원판을 2에서 0으로 옮긴다.
원판을 2에서 1로 옮긴다.            - f(3)
원판을 0에서 1로 옮긴다.
원판을 0에서 2로 옮긴다.            - f(1)
원판을 1에서 2로 옮긴다.
원판을 1에서 0으로 옮긴다.          - f(3)
원판을 2에서 0으로 옮긴다.
원판을 1에서 2로 옮긴다.            - f(2)
원판을 0에서 1로 옮긴다.
원판을 0에서 2로 옮긴다.            - f(3)
원판을 1에서 2로 옮긴다.
```


<br><br>
한 눈에 잘 보이지는 않지만, 어쨌든 무언가 규칙성이 있는 것 같다는 느낌 자체는 올 것 같죠?
<br><br><br><br><br><br><br><br>


## 3) 하노이의 탑의 규칙성
<br>

이렇게 직접 옮겨본 다음에 무엇을 알 수 있었나요?<br><br><br>

첫 번째는 `원판이 더 적은 경우의 수가 항상 원판이 더 많은 경우에 포함`되어있다는거에요.<br><br>
f(4)는 f(4)만의 별도의 규칙(원판이 하나 더 늘었기 때문에)을 제외하고는 f(3), f(2), f(1)도 포함되어있죠.<br>

이건 원판이 2개, 3개, 4개, ... n개일 때에도 언제나 성립할거에요.
<br><br><br><br><br><br>


두 번째는 원판이 하나일 때 기준으로 `대칭을 이룬다`는거에요.<br>

원판이 두 개(크기 내림차 순으로 A, B) 일 때, 이동 단계는 3입니다.
```
1. B 원판을 0에서 1로 옮긴다.
2. A 원판을 0에서 2로 옮긴다.       - f(1)
3. B 원판을 1에서 2로 옮긴다.
```

1번에서 이동한 만큼 3번에서도 똑같이 이동이 일어나고 있죠?<br>

원판이 세 개 일때는요?
```
1. C 원판을 0에서 2로 옮긴다.      
2. B 원판을 0에서 1로 옮긴다.
3. C 원판을 2에서 1로 옮긴다.
4. A 원판을 0에서 2로 옮긴다.       - f(1)
5. C 원판을 1에서 0으로 옮긴다.
6. B 원판을 1에서 2로 옮긴다.
7. C 원판을 0에서 2로 옮긴다.
```

1~3번까지 CBC가 이동하고, 또 5~7번까지 CBC가 같은 이동 횟수만큼 움직이고 있어요.<br><br><br><br>

아직도 대칭성이 한 눈에 들어오지 않는다면, 이렇게 해볼까요?<br>

이제 기둥은 `0, 1, 2`가 아니라, `0, 1, 0`입니다.<br>
쉽게 생각하세요.<br>
>***집에서 학교를 들렀다가, 다시 집으로 오는 코스를 일직선으로 길게 늘렸다***고 생각해보세요.

<br>

```
1. C 원판을 0에서 0으로 옮긴다.      
2. B 원판을 0에서 1로 옮긴다.
3. C 원판을 0에서 1로 옮긴다.
4. A 원판을 0에서 0으로 옮긴다.     - f(1)
5. C 원판을 1에서 0으로 옮긴다.
6. B 원판을 1에서 0으로 옮긴다.
7. C 원판을 0에서 0으로 옮긴다.
```

...어때요? 좀 더 대칭성이 한 눈에 들어오나요?
<br><br>

f(n)이 대칭성을 가질 때, `대칭이 이루어지는 순간은 항상 1 ~ n-1개의 원판이 가운데에 왔을 순간입니다.`

<br><br><br><br>

이것들을 가지고 다시 한 번 문제를 풀어보세요.
<br><br><br><br><br><br><br><br>



## 4) 하노이의 탑 알고리즘
<br>

이제 이를 기반으로 알고리즘,<br>
`RecurMoveDisk()`를 짜봅시다. <br>

`from`에서 `to`까지 원판을 옮기는 함수<br>
`MoveDisk(int from, int to)`가 있다고 먼저 가정을 할게요.<br>

우리는 재귀함수를 구현할거니까, 우선 무한루프에 빠지지 않게 하기 위해 재귀에서 탈출하는 케이스를 생각해야겠죠?<br>

원판이 2개든, 3개든, 4개든, ... n개든, 유일하게 단 한 번 겪는 케이스가 있습니다. 바로 원판이 *하나*인 경우, f(1)인 경우에요.<br>

즉 탈출 조건은 `if(n == 1)`이 되겠죠.
<br><br><br>

n이 1일 때, 그러니까 f(1)에서는 뭘 해야하나요?<br>
아까 f(1)을 기준으로 대칭성을 가지기 직전에, n - 1개 까지의 원판은 모두 중앙에 있다고 했죠?<br>
우리가 해야할 건 이제 외롭게 남은 원판 n을 목적지로 옮겨주는 것입니다.<br>
```cpp
if(n == 1)
    MoveDisk(from, to)
```
<br><br><br>

탈출 조건은 짰고, 그럼 나머지의 경우는 어떨까요?

뭐 재귀구조니까 일단 스스로를 불러오긴 와야할 것 같아요. 그쵸?
```cpp
//n은 원판의 개수, from, temp, to는 각각 기둥
void RecurMoveDisk(int n, int from, int temp, int to)
{
    if(n == 1)
        MoveDisk(from, to)
    else
        RecurMoveDisk() //???
}
```

f(1)은 기둥 하나를 목적지까지 옮기고...<br>
f(2)는 그 다음 기둥을 0 -> 1 또는 1 -> 2로 옮기는 과정이죠?<br>
여기서 중요한건 `대칭성` 때문에 서로 다른 MoveDisk()가 두 번 들어가야 한다는 거에요.
<br><br>

그럼 이렇게 하면 될까요?<br>
```cpp
//n은 원판의 개수, from, temp, to는 각각 기둥
void RecurMoveDisk(int n, int from, int temp, int to)
{
    if(n == 1)
        MoveDisk(from, to)
    else
        RecurMoveDisk() //???
        MoveDisk(from, temp);
        MoveDisk(temp, to);
}
```
...당연히 안되겠죠?<br>
3번째 원판 역시 순서를 하드코딩할 수는 없으니까요.
<br><br>

여기서 생각해볼 것은, `세 기둥 중 중요한건 어느 기둥인가?` 입니다.<br>

아까 대칭성을 이루는 순간에, 우리는 0번과 1번 기둥에만 원판이 존재한다는 사실을 확인했습니다.<br>

즉, 기둥은 세 개지만 중요한건 `출발지`와 `목적지`라는거죠.<br>
```cpp
//n은 원판의 개수, from, temp, to는 각각 기둥
void RecurMoveDisk(int n, int from, int temp, int to)
{
    if(n == 1)
        MoveDisk(from, to)
    else
        RecurMoveDisk() //???
        MoveDisk(from, to);
}
```

그런데 이래버리면, 처음에는 0 -> 1로, 두 번째는 1 -> 2로 향하는 분기를 어떻게 나누죠?<br>
이제 이 경우는 `재귀호출`에 맡깁니다.<br><br>

첫 경우는 0이 출발지, 1이 목적지.<br>
```cpp
//n은 원판의 개수, from, temp, to는 각각 기둥
void RecurMoveDisk(int n, int from, int temp, int to)
{
    if(n == 1)
        MoveDisk(from, to)
    else
        RecurMoveDisk(n - 1, from, to, temp);
        MoveDisk(from, to);
}
```

<br>

그 다음 `대칭된` 경우에는 1이 출발지, 2가 목적지.<br>
```cpp
//n은 원판의 개수, from, temp, to는 각각 기둥
void RecurMoveDisk(int n, int from, int temp, int to)
{
    if(n == 1)
        MoveDisk(from, to)
    else
        RecurMoveDisk(n - 1, from, to, temp);
        MoveDisk(from, to);
        RecurMoveDisk(n - 1, temp, from, to);
}
```

나머지 하나 남은 기둥은 그저 임시공간으로서 사용됩니다.
