---
title: 참조 변수(Reference Value)에 대해
categories:
- C++
- 따배씨++
tags:
- C++
- 따배씨++
- 참조
- 참조변수
- reference
- 레퍼런스
date: '2024-01-30 20:24:31'
---

<br>

> C++ 초보가 따배씨++ 강의를 듣고 생긴 의문을 정리하고 고찰하는 게시글입니다.<br>
> 언제든지 잘못된 내용은 지적해주세요!!

<br>

> 📌 연관된 강좌는 **`6.14 - 참조 변수`** 입니다.<br>
> 또한 cppiso의 내용을 참고하였습니다.

<br><br>


*참조 변수에 관한 질문을 정리한 내용입니다.*

<br><br><br>

## 1) 참조 변수(Reference Value)
<br>

참조 변수는 alias(별칭)이에요. `레퍼런스에 의한 전달`에 자주 사용됩니다.<br>
```cpp
void swap(int& i, int& j)
{
  int tmp = i;
  i = j;
  j = tmp;
}

int main()
{
  int x, y;
  // ...
  swap(x,y);
  // ...
}
```

<br>

여기서 `i`와 `j`는 각각 `x`와 `y`의 '별칭'이 돼요.<br>
다른 말로 하면, i는 x의 포인터도 아니고, x의 복사본도 아닌 `'x'그 자체`입니다.<br>
주소도 포함이에요. &x와 &i를 찍어보면 같은 주소를 가리키고 있답니다.<br><br>

<span style="font-size:1.7em;">프로그래머로서 생각해야하는 레퍼런스가 무엇인가는 이게 끝이에요.</span>

<br><br><br><br><br><br><br><br>







## 2) 포인터 아닌가요?
<br>

cppiso에서는 참조 변수를 다음과 같이 설명합니다.<br>

> *우선, 객체 x에 대한 레퍼런스 i는 일반적으로 x의 주소를 가리키는 것은 맞다.<br>
> 하지만, 프로그래머가 `i++`라고 이야기 한다면, 컴파일러는 x를 증가시키는 코드를 생성해낼 것이다.<br>
> 특히 컴파일러가 x를 찾을 때 사용되는 주소 비트역시 변하지 않는다.<br>
> C 프로그래머는 C 스타일 포인터에 의한 전달과 무엇이 다르냐고 할 지도 모르겠다.<br>
> 왜냐하면 &를 매개변수 앞으로 옮기고, \*들을 제거하면 위와 같은 코드가 나올 것이기 때문이다. <br>
> 다르게 말하자면, C 프로그래머는 i를 x의 주소를 가진 포인터 (\*p) 매크로로 생각할 것 같다. (컴파일러가 자동으로 `i++`를 `(*p)++`로, `i = 7`은 `*p = 7`으로 변환할 수 있도록 말이다)*<br>


>  ***그럼에도 중요한건, 레퍼런스를 마치 '재미있어 보이는 포인터'로 생각하면 안된다는 것이다. 레퍼런스는 다른 이름을 가진 '객체'다. 객체에 대한 포인터도 아니고, 객체의 복사본도 아니다. 참조하는 개체와 별개로 레퍼런스 자체에 대해 작업을 수행할 수 있는 C++ 구문은 없다.***

<br><br><br><br><br><br><br><br><br>





## 3) 그냥 포인터만 쓰면 되지 왜 도입했죠? 그리고 도입할거면 포인터는 없애버리면 되잖아요.
<br>

C++의 포인터는 C로부터 상속받았어요. 그래서 특별히 문제가 일어나지 않는 한 없애기가 매우 애매하고 위험합니다.<br>
레퍼런스가 도입되었을 때의 장점은 여러가지가 있지만, `원래 연산자 오버로딩의 편의성을 위해 도입되었다`고 cppiso는 설명합니다.

```cpp
void f1(const complex* x, const complex* y) // 포인터로
{
    complex z = *x+*y;  // 우웩
    // ...
}

void f2(const complex& x, const complex& y) // 레퍼런스로
{
    complex z = x+y;    // 음 념념 굿
    // ...
}   
```

<br><br><br><br><br><br><br><br><br>





## 4) 그럼 언제 포인터를 쓰고, 언제 레퍼런스를 사용해야 하나요?
<br>

<span style="font-size:1.7em;">가능하면 레퍼런스를 사용하고, 필요할 때는 포인터를 사용하세요.</span>


<br><br><br>
(재위치(reseating)의 경우가 아닌)보통의 경우 레퍼런스가 더 선호돼요.<br>
여기서 재위치는 아래와 같은 케이스를 의미합니다.

```cpp
int& ref2 = num1;
ref2 = num2;
```

<br><br>

> 💡*주의하세요, 참조는 재위치(reseating)을 허용하지 않아요.*<br>

```cpp
bool tr = true;
bool fa = false;

bool& ref = tr;
ref = fa;
(tr == fa) ? cout << "true" : cout << "false";
```

```
true
```

<br><br>

> 또한 참조는 선언되는 순간 초기화되어야 하고, 이는 역참조된 nullptr가 아닌 값이어야 해요.

```cpp
int num1 = 5;
int num2 = 3;

//int& ref1         // Error. 참조는 선언과 동시에 초기화 되어야 해요.

int& ref2 = num1;
ref2 = num2;        
// 항상 기억하세요. 참조는 말 그대로 '참조'입니다. 
// 무언가를 재할당하면 원래 의도와는 다르게 실제 변수의 값이 바뀜을 유의하세요.

int* no = nullptr;
int& ref3 = *no;
// 오류를 출력하지 않는 컴파일러 또는 컴파일러 버전이 존재하지만, 
// C++ 표준에서는 이런 짓은 제발 그냥 포인터로 하라고 설명하고 있어요.
// 출처 : C++ 2014 섹션 8.3.2 [dcl.ref] p5
```

<br><br><br><br><br><br><br><br><br>





## 5) 좋아요, 언제 레퍼런스를 쓰면 돼죠?
<br>

<span style="font-size:1.5em;">1. 전달된 객체를 변경하려면 참조로 호출하거나 포인터를 사용하세요.</span><br>
<span style="font-size:1.5em;">2. 전달된 객체를 변경하고 싶지 않고 '크기가 큰 경우' const 참조로 호출하세요.</span><br>
<span style="font-size:1.5em;">3. 그렇지 않으면 값으로 호출하세요.</span>

<br><br>

> Q. 얼마나 큰 걸 말하는 건가요?<br>
> A. `'2워드'` 크기 이상(64비트 컴퓨터 기준 128비트 이상)이면 전부요!

<br><br>
또한 다음과 같은 주의사항을 잘 기억하세요.

> 인수를 변경할 때 참조를 사용해도 상관은 없어요.
> 단, `문맥상` '변경이 허용된다'는 점을 더 잘 나타낼 수 있는건 포인터를 사용하는 겁니다.<br>
> 또한 멤버 함수 호출은 본질적으로 객체에 대한 참조별 호출이므로, 객체의 값/상태를 수정하려고 할 때는 그냥 멤버 함수를 되도록 사용하세요.<br>
> 꼭 인수를 변경하는 것 만이 능사는 아니에요. 언제나 여러분에겐 `새 값 만들어서 복사해넣기` 선택지가 있다는 것을 잊지마세요. 사실 그게 더 코드 가독성에는 좋답니다.



<br><br><br><br><br><br><br><br><br>





## 6) 레퍼런스를 반환 값으로 받는 이유는 뭐죠?
<br>

> 📌 연관된 강좌 **`7.5 - 다양한 반환 값들`** 을 참고해보세요.<br>

<br>

함수 호출이 일반적인 경우와 다르게 `대입 연산자의 왼쪽` 에 나타나게 됩니다. 와!<br>
물론 f() = 10;같은 것이 쓸모있게 느껴지진 않습니다.<br>
하지만 배열같은 데이터구조를 다루는데에는 도움이 될 수 있습니다.<br>
원래 class Array에서 첨자 연산자 []는 오버로딩 된 `함수` 거든요!

```cpp
class Array {
public:
  int size() const;
  float& operator[] (int index);
  // ...
};

int main()
{
  Array a;
  for (int i = 0; i < a.size(); ++i)
    a[i] = 7;    // Array::operator[](int)를 호출합니다.
  // ...
}
```
